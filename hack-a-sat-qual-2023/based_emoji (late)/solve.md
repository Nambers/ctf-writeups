# Based emoji
## Description
🫠

🕳

💻😀

🧮😥

🇾 🇴 🇺 ⬛ 🇲 🇮 🇬 🇭 🇹 ⬛ 🇼 🇦 🇳 🇹 ⬛ 🇹 🇴 ⬛ 🇺 🇸 🇪 ⬛ 🇦 ⬛ 🇹 🇪 🇷 🇲 🇮 🇳 🇦 🇱 ⬛ 🇹 🇭 🇦 🇹 ⬛ 🇭 🇦 🇸 ⬛ 🇪 🇲 🇴 🇯 🇮 🇸

👍 🆗 🌈 💖

## Resource
None, this is a SSH-server based challenge.  
# Steps
After connected to the SSH server, we can see:
```
❗ ❗ ❗   🇹 🇭 🇮 🇸   🇮 🇸   🇦   🇹 🇪 🇸 🇹   🇴 🇫   🇹 🇭 🇪   🇪 🇲 🇴 🇯 🇮   🇧 🇷 🇴 🇦 🇩 🇨 🇦 🇸 🇹   🇸 🇾 🇸 🇹 🇪 🇲   ❗ ❗ ❗ 
🇼 🇪   🇦 🇷 🇪   🇺 🇸 🇮 🇳 🇬   🇧 🇦 🇸 🇪 ➖ 3 2   🇪 🇲 🇴 🇯 🇮   🇪 🇳 🇨 🇴 🇩 🇮 🇳 🇬 
🇹 🇭 🇦 🇹   🇲 🇪 🇦 🇳 🇸   🇪 🇦 🇨 🇭   🇪 🇲 🇴 🇯 🇮   🇷 🇪 🇵 🇷 🇪 🇸 🇪 🇳 🇹 🇸   5   🇧 🇮 🇹 🇸 

🇳   🟰   🛸🎉🍌💯📼💯💥🌞🦍💾🧂🧂🥵🎉🧂🦍🙌💽🌝🔥🤯🧨🤯🌟🤟👀🍌💯🌞🛰💥🙌🥵🤟🥃🥃🥵🌝🍌🥵🤟🤟📡💵🤯🧠🌎🧠🌟👄🎉🧠🤟👄🧨
🍌💥💥🌎👽💥🦍🥵🛰🌎🍌🥵🦍🧠🧨🤯🛰🙌🌟👽🌎📼🤟📡🛸🌞💯🗿👽🌟💩🌝🧠🎉🥵🥵🥵🦍🌞🥵🧨💥💩🦍🔥🗿💾🌛💥🛸💥👀🥵💽🔥💽🧠💽🗿🔥
🦍💥🛰🌝🛸🌛📡🍌🥵🤯💵🌟💥💵🛸👽🤯🤟👽🧂🧠🤯🦍👽🥵🥵🤯💽👽🤯📡🧨👽💥🙌🚀💯🌎🙌📼📼🤟🧂🥵👄🔥🌎🌞👄🦍👀💵💽👽🥵🧂👄💩🌛💵
🛰💯💵💽🌟🌞🧠🧨👀🗿💥🌎🍌🥵🙌💯🚀🌎🌞🌝🌛💯🛸💯🧠🌎👽🤯👄🦍💩🤟🥃🧨💵🗿🥵💵🛸👀🤟🧂🦍🗿💽🦍💩🌞💩👄🌟🧠🌝📡🤟🔥🦍👀📡🔥
🤯🥵💩🥵💾🍌🤟📡🍌📡🤟📼🤯🧠🥃💯🧨🧠👽📼👽🧠👄🥵🌟👀👽📡🥵💾🤟🗿💩🍌💯🛸👄🥵🚀👽🧠🛸🌞💩🗿🌟🌛💥🌞🥵🥵🌞🧨🔥🍌🌟📡💽🥃💾🛰🛰🔥🚀🚀🤯🌛🌎🌛👽🌞💩💥🛰🤟🙌🤟🧨🧂💽💥🧠🛸🎉🤟💾🍌🌛🛸💾🌟🥵🌝📡🛰🙌👽🧠👄🙌🥃🎉🛰👽🌝🤟💯💽🧨🔥🗿👄🚀🌞🙌🤯🥃🛰🔥💩
🗿🦍🌝🌎🗿💽🌝🌎🥵🥃🧠🤟💽🛸🦍👽🦍💯📡🤟💽🎉💽🙌🛰🌞🙌🌟🛰🔥🧂📼👽🥵🌝🥵🧂🍌🤟🥃💵🔥👽💽🎉💩💥👽👄🛰💯🌟💯🎉🌎
🇪   🟰   🥃🎉🎉🛰

🇭 🇪 🇷 🇪   🇦 🇷 🇪   🇦   🇫 🇪 🇼   🆓 🐝🐝🐝  🇹 🇴   🇬 🇪 🇹   🇾 🇴 🇺   🇸 🇹 🇦 🇷 🇹 🇪 🇩
0⃣   🟰   🎉
1⃣   🟰   🛰
2⃣   🟰   🥃

🇹 🇴   🇬 🇪 🇹   🇹 🇭 🇪   🚩  🇾 🇴 🇺   🇲 🇺 🇸 🇹   🇩 🇪 🇨 🇷 🇾 🇵 🇹   🇹 🇭 🇪   🚩
🔐 🚩 👇

🇨   🟰   🥃📡🌛👀📡👽💥🌞🧠🌟🧂🌛🦍🍌🌟👽💩🙌🛰🙌🧂👀🛸🦍🧠🧨🥃💩🚀🌛🤟🦍🗿🙌🛰💵💾🦍📡🙌💩🧨💥🥵💽🌎📡🌝🙌💵📼🛰🎉🙌🦍
👄🦍🔥🧂🌞🤯🌛💽🗿👽🙌🍌🌝🤯🦍🔥🧠🌝👀📡💯🌎🚀🌝🦍🌎🦍🧠🤯🔥🧠🔥🌛🥵🤯🥃🧂👽🌟👀🧨💵🤯🌝💵🎉💾📼👀🛸📡🙌🍌🌎💵🌞🧂👀🦍💽💾💵🌞🛸🧨🎉🦍🤯💾📡🚀🤯🥵🌛🥵💵🤟🌝🧠🧨🛰🤯🚀💵🛰🧠👽👄🤟🍌🧨🧨💵👄💩💥💩🗿💾📡🧨💵🙌🥵🛰👄💾🌝💥🤟🚀🚀🛸💩🌟🗿👀🌛🗿🦍
💾💵🥵🗿👽🌞🦍🍌🌝🎉🗿🔥👄🌞🌎💵🌎🌛💥🛰🛰🙌🛰👀🌛🧨🤟🌝💵💾🗿👄🚀💾🌝🌎🥃👄📼🔥💽🙌👀💽🌛🤟🌞🤟💽🧨🥃💯🌞🧨🌞🦍🗿🌎🧂🌟
🥃📼🌛🦍💽🤟📼🤟👽💵🌞🌞🌝🥵🛰🙌👀💯🧠💯💥🤟🧨💾🦍🍌👀🥃🥃🚀📡🗿👽🎉🥃🤯🌞🛰🎉💩🚀🤟🍌🥵🥵💵📡🌛🍌🥵🙌📼📡💵🌞🧂🧂  📼🧠🚀🌛💥🌎🧂🧠🌞🧨🧂👄🌟💾🧠🧠💯📡💵🗿🧨🌟👀🙌👽🦍🙌💯🌛🤯💩💽💩🌛👽🤟🤯🌟🗿🤟💩💾🌎🗿🤯👄👄🤟💩🥵🤯💥📼🥃💯💥💾🧨💾🚀💥🦍💥💯🦍🎉🌛🤟🛰🗿🌝👽🤟💯📡🔥🔥🌟🤯🥃🔥🎉📼🌎🙌👀🌞👀💥🚀🧂🌟🤟🌞🚀🥵💽👀📡🦍🧠🤟💥💵🌝🥵🧨🙌💽🎉🙌💯🧂🌟🎉💯🧠🤟```

🇲 🇪 🇳 🇺
🇵 🇷 🇪 🇸 🇸   1⃣   🇹 🇴   🇬 🇪 🇹   🇹 🇭 🇪   🇫 🇦 🇨 🇹 🇴 🇷 🇸   🇴 🇫   🇦 🇳   🇪 🇲 🇴 🇯 🇮
🇵 🇷 🇪 🇸 🇸   2⃣   🇹 🇴   🇬 🇪 🇹   🇦   🇷 🇦 🇳 🇩 🇴 🇲   🇵 🇷 🇮 🇲 🇪   🇧 🇾   🇧 🇮 🇹 🇸
🇵 🇷 🇪 🇸 🇸   3⃣   🇹 🇴   🇬 🇪 🇹   🇹 🇭 🇪   🇫 🇦 🇨 🇹 🇴 🇷 🇸   🇴 🇫   🇦   🇷 🇦 🇳 🇩 🇴 🇲   🇳 🇺 🇲 🇧 🇪 🇷   🇹 🇭 🇦 🇹   🇮 🇸   🇦 🇹   🇴 🇻 🇪 🇷   5⃣   🇧 🇮 🇹 🇸   🇮 🇳   🇸 🇮 🇿 🇪
🇵 🇷 🇪 🇸 🇸   🇦 🇳 🇾 🇹 🇭 🇮 🇳 🇬   🇪 🇱 🇸 🇪   🇹 🇴   🇪 🇽 🇮 🇹
```
Each emoji represents a 32-based number, and the N, E, C show that this is relative to RSA. So that the first step is solve the value of every emoji.  
## Emoji decode part
Z3 solver is the first things pop in my mind.  
At first, I use a python script to get factors of every emoji by menu option 1.  
(here is supposed to be a script, but I lost it)  
therefore, here is the result:
```python
{'🎉': '0', '🛰': '1', '🥃': '2', '🌝': ' 🛰  🌝 ', '💾': ' 🛰  🦍  🌟  💾 ', '🛸': ' 🛰  🦍  🥃  🛸 ', '🤯': ' 🛰  🌎  🤯 ', '🙌': ' 🛰  🙌 ', '📡': ' 🛰  📡  🥃 ', '🦍': ' 🛰  🦍 ', '👀': ' 🛰  🥃  🌎  👀 ', '💥': ' 🦍  🥃  🛰  💩  💽  💥  📡  🛸 ', '🥵': ' 🥃  🛰  💩  📡  🥵 ', '💩': ' 💩  🛰  📡  🥃 ', '💵': ' 🦍  🌟  🥃  🛰  💵  🛸 ', '🌛': ' 🦍  🥃  🧠  🛰  🌎  👀  🌛  🛸 ', '🌞': ' 🛰  🌝  🥃  🌞 ', '🌟': ' 🛰  🦍  🌟 ', '👽': ' 🛰  👽 ', '🗿': ' 🛰  🗿  🦍  🚀 ', '🌎': ' 🛰  🌎 ', '💽': ' 🦍  🥃  🛰  💽  📡  🛸 ', '👄': ' 🛰  👄 ', '🍌': ' 🍌  🥃  🛰  🚀  📡  🧨 ', '🔥': ' 🛰  🔥 ', '🤟': ' 🛰  🤟 ', '🧨': ' 🛰  🚀  🧨  🥃 ', '🧂': ' 🛰  🧂 ', '🚀': ' 🛰  🚀 ', '🧠': ' 🛰  🌎  🦍  🧠 ', '💯': ' 🛰  🔥  💯  🥃 ', '📼': ' 🥃  🛰  🌎  📼  📡  👀 '}
```
Then, is the time for z3.  
Firstly, build a `z3.Int` list, which represents every emoji's value.  
```python
words={'🎉': '0', '🛰': '1', '🥃': '2', '🌝': ' 🛰  🌝 ', '💾': ' 🛰  🦍  🌟  💾 ', '🛸': ' 🛰  🦍  🥃  🛸 ', '🤯': ' 🛰  🌎  🤯 ', '🙌': ' 🛰  🙌 ', '📡': ' 🛰  📡  🥃 ', '🦍': ' 🛰  🦍 ', '👀': ' 🛰  🥃  🌎  👀 ', '💥': ' 🦍  🥃  🛰  💩  💽  💥  📡  🛸 ', '🥵': ' 🥃  🛰  💩  📡  🥵 ', '💩': ' 💩  🛰  📡  🥃 ', '💵': ' 🦍  🌟  🥃  🛰  💵  🛸 ', '🌛': ' 🦍  🥃  🧠  🛰  🌎  👀  🌛  🛸 ', '🌞': ' 🛰  🌝  🥃  🌞 ', '🌟': ' 🛰  🦍  🌟 ', '👽': ' 🛰  👽 ', '🗿': ' 🛰  🗿  🦍  🚀 ', '🌎': ' 🛰  🌎 ', '💽': ' 🦍  🥃  🛰  💽  📡  🛸 ', '👄': ' 🛰  👄 ', '🍌': ' 🍌  🥃  🛰  🚀  📡  🧨 ', '🔥': ' 🛰  🔥 ', '🤟': ' 🛰  🤟 ', '🧨': ' 🛰  🚀  🧨  🥃 ', '🧂': ' 🛰  🧂 ', '🚀': ' 🛰  🚀 ', '🧠': ' 🛰  🌎  🦍  🧠 ', '💯': ' 🛰  🔥  💯  🥃 ', '📼': ' 🥃  🛰  🌎  📼  📡  👀 '}
from z3 import IntVal, Int, Solver, Distinct
s=Solver()
vals=[IntVal(a) for a in range(3)] + [Int("val" + str(i))]
```
Then add basic constraints (2 < value < 32) for every emoji.  
```python
for v in vals[3:]:
    s.add(v >= IntVal(3))
    s.add(v < IntVal(32))

# bc each value should be distinct
s.add(Distinct(vals))
```
Absolutely we can run with these basic constraints, but the result will be ambiguous. Therefore, we need to add more constraints from menu option 2 (get random prime emoji in specific bits):  
```python
def addConstraintOfPrimeBit(num, bitNum):
    global s, vals
    val=vals[num]
    lowerBound=int('1' + '0' * (bitNum - 1), 2)
    # add lower bound constrains
    s.add(val<=IntVal(int('1' * bitNum, 2)))
    # add upper  bound constraint
    s.add(val>=IntVal(lowerBound))
    # add prime constraint
    if lowerBound > 2:
        for i in range(2, lowerBound):
            # print(f"val{num} % {i} != 0")
            s.add(val % IntVal(i) != IntVal(0))
```
And manually get some emojis from menu option 2.
```python
# 🇷 🇦 🇳 🇩 🇴 🇲   2⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🦍
# 🦍 is prime and 🦍 is 2bits, so 2 < it <= 3
addConstraintOfPrimeBit(keys.index('🦍'), 2)

# 🇷 🇦 🇳 🇩 🇴 🇲   3⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🌎
addConstraintOfPrimeBit(keys.index('🌎'), 3)

# 🇷 🇦 🇳 🇩 🇴 🇲   3⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🚀
addConstraintOfPrimeBit(keys.index('🚀'), 3)

# 🇷 🇦 🇳 🇩 🇴 🇲   4⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🔥
addConstraintOfPrimeBit(keys.index('🔥'), 4)

# 🇷 🇦 🇳 🇩 🇴 🇲   4⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🌝
addConstraintOfPrimeBit(keys.index('🌝'), 4)

# 🇷 🇦 🇳 🇩 🇴 🇲   5⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🙌
addConstraintOfPrimeBit(keys.index('🙌'), 5)

# 🇷 🇦 🇳 🇩 🇴 🇲   5⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    🧂
addConstraintOfPrimeBit(keys.index('🧂'), 5)

# 🇷 🇦 🇳 🇩 🇴 🇲   5⃣   ➖ 🇧 🇮 🇹   🇵 🇷 🇮 🇲 🇪   🟰    👄
addConstraintOfPrimeBit(keys.index('👄'), 5)
```
But the result is still ambiguous (at least one emoji value is ambiguous, e.g. 💯 can be 22 or 26). At first, I try to utilize results from menu option 3, but those constrains will make solver `unsat` (although we don't care what is the value of those random bits value):
```python
# these stuff will make solver be unsat. I don't know why
# #  🦍  🛰💯  🛸  💵  🌟  🥃  🛰  💾 of 6 bits
# random_6_bit = Int("random_6_bit")
# s.add(random_6_bit % vals[keys.index('🦍')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('💯')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('🛸')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('💵')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('🌟')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('🥃')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('💾')] == IntVal(0))
# s.add(random_6_bit >= IntVal(int('100000', 2)))
# s.add(random_6_bit <= IntVal(int('111111', 2)))

# #  🛰  🌝  🦍  🛰🚀 of 6 bits
# random_6_bit2 = Int("random_6_bit2")
# s.add(random_6_bit2 % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('🌝')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('🦍')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('🚀')] == IntVal(0))
# s.add(random_6_bit2 >= IntVal(int('100000', 2)))
# s.add(random_6_bit2 <= IntVal(int('111111', 2)))

# #  👀  🛰💩  🌎  🥃  💩  📼  📡  🛰 of 6 bits
# random_6_bit3 = Int("random_6_bit3")
# s.add(random_6_bit3 % vals[keys.index('👀')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('💩')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('🌎')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('🥃')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('💩')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('📼')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('📡')] == IntVal(0))
# s.add(random_6_bit3 >= IntVal(int('100000', 2)))
# s.add(random_6_bit3 <= IntVal(int('111111', 2)))

# # 🥃  🤟  🛰  🛰🛸 of 6 bits
# random_6_bit4 = Int("random_6_bit4")
# s.add(random_6_bit4 % vals[keys.index('🥃')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('🤟')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('🛸')] == IntVal(0))
# s.add(random_6_bit4 >= IntVal(int('100000', 2)))
# s.add(random_6_bit4 <= IntVal(int('111111', 2)))

# # 🍌  🦍🥵  🚀  🥃  🧨  🥵  💩  🛰💥  📡  🛰 of 7 bits
# random_7_bit = Int("random_7_bit")
# s.add(random_7_bit % vals[keys.index('🍌')] == IntVal(0))
# s.add(random_7_bit % (vals[keys.index('🦍')] * vals[keys.index('🥵')]) == IntVal(0))
# s.add(random_7_bit % vals[keys.index('🚀')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('🥃')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('🧨')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('🥵')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('💩')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('💥')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('📡')] == IntVal(0))
# s.add(random_7_bit >= IntVal(int('1000000', 2)))
# s.add(random_7_bit <= IntVal(int('1111111', 2)))

# #  🛰👽  🦍🥃  🧨  🥃  🚀  🛰 for 7 bits
# random_7_bit2 = Int("random_7_bit2")
# s.add(random_7_bit2 % (vals[keys.index('👽')]) == IntVal(0))
# s.add(random_7_bit2 % (vals[keys.index('🦍')] * vals[keys.index('🥃')]) == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('🧨')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('🥃')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('🚀')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('🛰')] == IntVal(0))
# s.add(random_7_bit2 >= IntVal(int('1000000', 2)))
# s.add(random_7_bit2 <= IntVal(int('1111111', 2)))
```
Therefore, there is no choice but do some manually analysis (analyzed by **qxxxb**):
```python
# manually found, if not, there will be some ambiguity, e.g. 💯 can be 22 or 26
s.add(vals[keys.index('📡')] == IntVal(4))
s.add(vals[keys.index('💩')] == IntVal(8))
s.add(vals[keys.index('🥵')] == IntVal(16))
s.add(vals[keys.index('🛸')] == IntVal(6))
s.add(vals[keys.index('💽')] == IntVal(12))
s.add(vals[keys.index('🚀')] == IntVal(7))
s.add(vals[keys.index('🌎')] == IntVal(5))
s.add(vals[keys.index('🔥')] == IntVal(11))
s.add(vals[keys.index('🌝')] == IntVal(13))
s.add(vals[keys.index('🧂')] == IntVal(23))
s.add(vals[keys.index('👽')] == IntVal(17))
s.add(vals[keys.index('🤟')] == IntVal(19))
s.add(vals[keys.index('🙌')] == IntVal(29))
s.add(vals[keys.index('👄')] == IntVal(31))
```
and the part print result:  
```python
print("constraints added finished")
print(s.check())
model = str(s.model())
print(model)
```
Our z3 script is finished, and offer us a transcript between emoji and 32-based integer:
```
 {'🎉': 0, '🛰': 1, '🥃': 2, '💯': 22, '🧠': 15, '👀': 10, '🥵': 16, '🌛': 30, '🙌': 29, '👽': 17, '🤯': 25, '🌞': 26, '💾': 27, '💽': 12, '🗿': 21, '🚀': 7,  '💵': 18, '🌝': 13, '🧨': 14, '💥': 24, '💩': 8, '🤟': 19, '🧂': 23, '🦍': 3, '🔥': 11, '📡': 4, '👄': 31, '🛸': 6, '🌟': 9, '🌎': 5, '📼': 20, '🍌': 28}
```
## RSA decode part
At first, we though the N, E and C is a RSA cipher (but it is not).  So we spend a lot of time on `RsaCtfTool` and `Yafu` to attack this RSA, and we got nothing.  
Eventually, after this CTF is over, we figure out that this is a RSA signature (from Discord).  
So, this is the last piece of script (wrote by **qxxxb**):
```python
transcript = emojis

import pwn

def digit_to_keycap(n: int) -> bytes:
    assert 0 <= n < 10
    return str(n).encode() + b"\xe2\x83\xa3"

def emojis_to_n(emojis: str) -> int:
    n = 0
    for emoji in emojis:
        x = transcript[emoji]
        n = n * 32 + x
    return n

pwn.context.log_level = "debug"

io = pwn.remote("emoji.quals2023.satellitesabove.me", 5300)
io.sendlineafter(
    b"Ticket please:\n",
    b"ticket",
)

io.recvuntil("🇳   🟰   ")
N = io.recvline().strip().decode()

io.recvuntil("🇪   🟰   ")
E = io.recvline().strip().decode()

io.recvuntil("🇨   🟰   ")
C = io.recvline().strip().decode()

n = emojis_to_n(N)
e = emojis_to_n(E)
c = emojis_to_n(C)

print(f"n = {n}")
print(f"e = {e}")
print(f"c = {c}")

import Crypto.Util.number as cun

p = pow(c, e, n)

# flag
print(cun.long_to_bytes(p))
```
# Solution
check `solve.py` in same directory.