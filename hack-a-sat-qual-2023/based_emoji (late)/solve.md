# Based emoji
## Description
ğŸ« 

ğŸ•³

ğŸ’»ğŸ˜€

ğŸ§®ğŸ˜¥

ğŸ‡¾ ğŸ‡´ ğŸ‡º â¬› ğŸ‡² ğŸ‡® ğŸ‡¬ ğŸ‡­ ğŸ‡¹ â¬› ğŸ‡¼ ğŸ‡¦ ğŸ‡³ ğŸ‡¹ â¬› ğŸ‡¹ ğŸ‡´ â¬› ğŸ‡º ğŸ‡¸ ğŸ‡ª â¬› ğŸ‡¦ â¬› ğŸ‡¹ ğŸ‡ª ğŸ‡· ğŸ‡² ğŸ‡® ğŸ‡³ ğŸ‡¦ ğŸ‡± â¬› ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹ â¬› ğŸ‡­ ğŸ‡¦ ğŸ‡¸ â¬› ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡® ğŸ‡¸

ğŸ‘ ğŸ†— ğŸŒˆ ğŸ’–

## Resource
None, this is a SSH-server based challenge.  
# Steps
After connected to the SSH server, we can see:
```
â— â— â—   ğŸ‡¹ ğŸ‡­ ğŸ‡® ğŸ‡¸   ğŸ‡® ğŸ‡¸   ğŸ‡¦   ğŸ‡¹ ğŸ‡ª ğŸ‡¸ ğŸ‡¹   ğŸ‡´ ğŸ‡«   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡§ ğŸ‡· ğŸ‡´ ğŸ‡¦ ğŸ‡© ğŸ‡¨ ğŸ‡¦ ğŸ‡¸ ğŸ‡¹   ğŸ‡¸ ğŸ‡¾ ğŸ‡¸ ğŸ‡¹ ğŸ‡ª ğŸ‡²   â— â— â— 
ğŸ‡¼ ğŸ‡ª   ğŸ‡¦ ğŸ‡· ğŸ‡ª   ğŸ‡º ğŸ‡¸ ğŸ‡® ğŸ‡³ ğŸ‡¬   ğŸ‡§ ğŸ‡¦ ğŸ‡¸ ğŸ‡ª â– 3 2   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡ª ğŸ‡³ ğŸ‡¨ ğŸ‡´ ğŸ‡© ğŸ‡® ğŸ‡³ ğŸ‡¬ 
ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹   ğŸ‡² ğŸ‡ª ğŸ‡¦ ğŸ‡³ ğŸ‡¸   ğŸ‡ª ğŸ‡¦ ğŸ‡¨ ğŸ‡­   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡· ğŸ‡ª ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡ª ğŸ‡³ ğŸ‡¹ ğŸ‡¸   5   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸ 

ğŸ‡³   ğŸŸ°   ğŸ›¸ğŸ‰ğŸŒğŸ’¯ğŸ“¼ğŸ’¯ğŸ’¥ğŸŒğŸ¦ğŸ’¾ğŸ§‚ğŸ§‚ğŸ¥µğŸ‰ğŸ§‚ğŸ¦ğŸ™ŒğŸ’½ğŸŒğŸ”¥ğŸ¤¯ğŸ§¨ğŸ¤¯ğŸŒŸğŸ¤ŸğŸ‘€ğŸŒğŸ’¯ğŸŒğŸ›°ğŸ’¥ğŸ™ŒğŸ¥µğŸ¤ŸğŸ¥ƒğŸ¥ƒğŸ¥µğŸŒğŸŒğŸ¥µğŸ¤ŸğŸ¤ŸğŸ“¡ğŸ’µğŸ¤¯ğŸ§ ğŸŒğŸ§ ğŸŒŸğŸ‘„ğŸ‰ğŸ§ ğŸ¤ŸğŸ‘„ğŸ§¨
ğŸŒğŸ’¥ğŸ’¥ğŸŒğŸ‘½ğŸ’¥ğŸ¦ğŸ¥µğŸ›°ğŸŒğŸŒğŸ¥µğŸ¦ğŸ§ ğŸ§¨ğŸ¤¯ğŸ›°ğŸ™ŒğŸŒŸğŸ‘½ğŸŒğŸ“¼ğŸ¤ŸğŸ“¡ğŸ›¸ğŸŒğŸ’¯ğŸ—¿ğŸ‘½ğŸŒŸğŸ’©ğŸŒğŸ§ ğŸ‰ğŸ¥µğŸ¥µğŸ¥µğŸ¦ğŸŒğŸ¥µğŸ§¨ğŸ’¥ğŸ’©ğŸ¦ğŸ”¥ğŸ—¿ğŸ’¾ğŸŒ›ğŸ’¥ğŸ›¸ğŸ’¥ğŸ‘€ğŸ¥µğŸ’½ğŸ”¥ğŸ’½ğŸ§ ğŸ’½ğŸ—¿ğŸ”¥
ğŸ¦ğŸ’¥ğŸ›°ğŸŒğŸ›¸ğŸŒ›ğŸ“¡ğŸŒğŸ¥µğŸ¤¯ğŸ’µğŸŒŸğŸ’¥ğŸ’µğŸ›¸ğŸ‘½ğŸ¤¯ğŸ¤ŸğŸ‘½ğŸ§‚ğŸ§ ğŸ¤¯ğŸ¦ğŸ‘½ğŸ¥µğŸ¥µğŸ¤¯ğŸ’½ğŸ‘½ğŸ¤¯ğŸ“¡ğŸ§¨ğŸ‘½ğŸ’¥ğŸ™ŒğŸš€ğŸ’¯ğŸŒğŸ™ŒğŸ“¼ğŸ“¼ğŸ¤ŸğŸ§‚ğŸ¥µğŸ‘„ğŸ”¥ğŸŒğŸŒğŸ‘„ğŸ¦ğŸ‘€ğŸ’µğŸ’½ğŸ‘½ğŸ¥µğŸ§‚ğŸ‘„ğŸ’©ğŸŒ›ğŸ’µ
ğŸ›°ğŸ’¯ğŸ’µğŸ’½ğŸŒŸğŸŒğŸ§ ğŸ§¨ğŸ‘€ğŸ—¿ğŸ’¥ğŸŒğŸŒğŸ¥µğŸ™ŒğŸ’¯ğŸš€ğŸŒğŸŒğŸŒğŸŒ›ğŸ’¯ğŸ›¸ğŸ’¯ğŸ§ ğŸŒğŸ‘½ğŸ¤¯ğŸ‘„ğŸ¦ğŸ’©ğŸ¤ŸğŸ¥ƒğŸ§¨ğŸ’µğŸ—¿ğŸ¥µğŸ’µğŸ›¸ğŸ‘€ğŸ¤ŸğŸ§‚ğŸ¦ğŸ—¿ğŸ’½ğŸ¦ğŸ’©ğŸŒğŸ’©ğŸ‘„ğŸŒŸğŸ§ ğŸŒğŸ“¡ğŸ¤ŸğŸ”¥ğŸ¦ğŸ‘€ğŸ“¡ğŸ”¥
ğŸ¤¯ğŸ¥µğŸ’©ğŸ¥µğŸ’¾ğŸŒğŸ¤ŸğŸ“¡ğŸŒğŸ“¡ğŸ¤ŸğŸ“¼ğŸ¤¯ğŸ§ ğŸ¥ƒğŸ’¯ğŸ§¨ğŸ§ ğŸ‘½ğŸ“¼ğŸ‘½ğŸ§ ğŸ‘„ğŸ¥µğŸŒŸğŸ‘€ğŸ‘½ğŸ“¡ğŸ¥µğŸ’¾ğŸ¤ŸğŸ—¿ğŸ’©ğŸŒğŸ’¯ğŸ›¸ğŸ‘„ğŸ¥µğŸš€ğŸ‘½ğŸ§ ğŸ›¸ğŸŒğŸ’©ğŸ—¿ğŸŒŸğŸŒ›ğŸ’¥ğŸŒğŸ¥µğŸ¥µğŸŒğŸ§¨ğŸ”¥ğŸŒğŸŒŸğŸ“¡ğŸ’½ğŸ¥ƒğŸ’¾ğŸ›°ğŸ›°ğŸ”¥ğŸš€ğŸš€ğŸ¤¯ğŸŒ›ğŸŒğŸŒ›ğŸ‘½ğŸŒğŸ’©ğŸ’¥ğŸ›°ğŸ¤ŸğŸ™ŒğŸ¤ŸğŸ§¨ğŸ§‚ğŸ’½ğŸ’¥ğŸ§ ğŸ›¸ğŸ‰ğŸ¤ŸğŸ’¾ğŸŒğŸŒ›ğŸ›¸ğŸ’¾ğŸŒŸğŸ¥µğŸŒğŸ“¡ğŸ›°ğŸ™ŒğŸ‘½ğŸ§ ğŸ‘„ğŸ™ŒğŸ¥ƒğŸ‰ğŸ›°ğŸ‘½ğŸŒğŸ¤ŸğŸ’¯ğŸ’½ğŸ§¨ğŸ”¥ğŸ—¿ğŸ‘„ğŸš€ğŸŒğŸ™ŒğŸ¤¯ğŸ¥ƒğŸ›°ğŸ”¥ğŸ’©
ğŸ—¿ğŸ¦ğŸŒğŸŒğŸ—¿ğŸ’½ğŸŒğŸŒğŸ¥µğŸ¥ƒğŸ§ ğŸ¤ŸğŸ’½ğŸ›¸ğŸ¦ğŸ‘½ğŸ¦ğŸ’¯ğŸ“¡ğŸ¤ŸğŸ’½ğŸ‰ğŸ’½ğŸ™ŒğŸ›°ğŸŒğŸ™ŒğŸŒŸğŸ›°ğŸ”¥ğŸ§‚ğŸ“¼ğŸ‘½ğŸ¥µğŸŒğŸ¥µğŸ§‚ğŸŒğŸ¤ŸğŸ¥ƒğŸ’µğŸ”¥ğŸ‘½ğŸ’½ğŸ‰ğŸ’©ğŸ’¥ğŸ‘½ğŸ‘„ğŸ›°ğŸ’¯ğŸŒŸğŸ’¯ğŸ‰ğŸŒ
ğŸ‡ª   ğŸŸ°   ğŸ¥ƒğŸ‰ğŸ‰ğŸ›°

ğŸ‡­ ğŸ‡ª ğŸ‡· ğŸ‡ª   ğŸ‡¦ ğŸ‡· ğŸ‡ª   ğŸ‡¦   ğŸ‡« ğŸ‡ª ğŸ‡¼   ğŸ†“ ğŸğŸğŸ  ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¾ ğŸ‡´ ğŸ‡º   ğŸ‡¸ ğŸ‡¹ ğŸ‡¦ ğŸ‡· ğŸ‡¹ ğŸ‡ª ğŸ‡©
0âƒ£   ğŸŸ°   ğŸ‰
1âƒ£   ğŸŸ°   ğŸ›°
2âƒ£   ğŸŸ°   ğŸ¥ƒ

ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸš©  ğŸ‡¾ ğŸ‡´ ğŸ‡º   ğŸ‡² ğŸ‡º ğŸ‡¸ ğŸ‡¹   ğŸ‡© ğŸ‡ª ğŸ‡¨ ğŸ‡· ğŸ‡¾ ğŸ‡µ ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸš©
ğŸ” ğŸš© ğŸ‘‡

ğŸ‡¨   ğŸŸ°   ğŸ¥ƒğŸ“¡ğŸŒ›ğŸ‘€ğŸ“¡ğŸ‘½ğŸ’¥ğŸŒğŸ§ ğŸŒŸğŸ§‚ğŸŒ›ğŸ¦ğŸŒğŸŒŸğŸ‘½ğŸ’©ğŸ™ŒğŸ›°ğŸ™ŒğŸ§‚ğŸ‘€ğŸ›¸ğŸ¦ğŸ§ ğŸ§¨ğŸ¥ƒğŸ’©ğŸš€ğŸŒ›ğŸ¤ŸğŸ¦ğŸ—¿ğŸ™ŒğŸ›°ğŸ’µğŸ’¾ğŸ¦ğŸ“¡ğŸ™ŒğŸ’©ğŸ§¨ğŸ’¥ğŸ¥µğŸ’½ğŸŒğŸ“¡ğŸŒğŸ™ŒğŸ’µğŸ“¼ğŸ›°ğŸ‰ğŸ™ŒğŸ¦
ğŸ‘„ğŸ¦ğŸ”¥ğŸ§‚ğŸŒğŸ¤¯ğŸŒ›ğŸ’½ğŸ—¿ğŸ‘½ğŸ™ŒğŸŒğŸŒğŸ¤¯ğŸ¦ğŸ”¥ğŸ§ ğŸŒğŸ‘€ğŸ“¡ğŸ’¯ğŸŒğŸš€ğŸŒğŸ¦ğŸŒğŸ¦ğŸ§ ğŸ¤¯ğŸ”¥ğŸ§ ğŸ”¥ğŸŒ›ğŸ¥µğŸ¤¯ğŸ¥ƒğŸ§‚ğŸ‘½ğŸŒŸğŸ‘€ğŸ§¨ğŸ’µğŸ¤¯ğŸŒğŸ’µğŸ‰ğŸ’¾ğŸ“¼ğŸ‘€ğŸ›¸ğŸ“¡ğŸ™ŒğŸŒğŸŒğŸ’µğŸŒğŸ§‚ğŸ‘€ğŸ¦ğŸ’½ğŸ’¾ğŸ’µğŸŒğŸ›¸ğŸ§¨ğŸ‰ğŸ¦ğŸ¤¯ğŸ’¾ğŸ“¡ğŸš€ğŸ¤¯ğŸ¥µğŸŒ›ğŸ¥µğŸ’µğŸ¤ŸğŸŒğŸ§ ğŸ§¨ğŸ›°ğŸ¤¯ğŸš€ğŸ’µğŸ›°ğŸ§ ğŸ‘½ğŸ‘„ğŸ¤ŸğŸŒğŸ§¨ğŸ§¨ğŸ’µğŸ‘„ğŸ’©ğŸ’¥ğŸ’©ğŸ—¿ğŸ’¾ğŸ“¡ğŸ§¨ğŸ’µğŸ™ŒğŸ¥µğŸ›°ğŸ‘„ğŸ’¾ğŸŒğŸ’¥ğŸ¤ŸğŸš€ğŸš€ğŸ›¸ğŸ’©ğŸŒŸğŸ—¿ğŸ‘€ğŸŒ›ğŸ—¿ğŸ¦
ğŸ’¾ğŸ’µğŸ¥µğŸ—¿ğŸ‘½ğŸŒğŸ¦ğŸŒğŸŒğŸ‰ğŸ—¿ğŸ”¥ğŸ‘„ğŸŒğŸŒğŸ’µğŸŒğŸŒ›ğŸ’¥ğŸ›°ğŸ›°ğŸ™ŒğŸ›°ğŸ‘€ğŸŒ›ğŸ§¨ğŸ¤ŸğŸŒğŸ’µğŸ’¾ğŸ—¿ğŸ‘„ğŸš€ğŸ’¾ğŸŒğŸŒğŸ¥ƒğŸ‘„ğŸ“¼ğŸ”¥ğŸ’½ğŸ™ŒğŸ‘€ğŸ’½ğŸŒ›ğŸ¤ŸğŸŒğŸ¤ŸğŸ’½ğŸ§¨ğŸ¥ƒğŸ’¯ğŸŒğŸ§¨ğŸŒğŸ¦ğŸ—¿ğŸŒğŸ§‚ğŸŒŸ
ğŸ¥ƒğŸ“¼ğŸŒ›ğŸ¦ğŸ’½ğŸ¤ŸğŸ“¼ğŸ¤ŸğŸ‘½ğŸ’µğŸŒğŸŒğŸŒğŸ¥µğŸ›°ğŸ™ŒğŸ‘€ğŸ’¯ğŸ§ ğŸ’¯ğŸ’¥ğŸ¤ŸğŸ§¨ğŸ’¾ğŸ¦ğŸŒğŸ‘€ğŸ¥ƒğŸ¥ƒğŸš€ğŸ“¡ğŸ—¿ğŸ‘½ğŸ‰ğŸ¥ƒğŸ¤¯ğŸŒğŸ›°ğŸ‰ğŸ’©ğŸš€ğŸ¤ŸğŸŒğŸ¥µğŸ¥µğŸ’µğŸ“¡ğŸŒ›ğŸŒğŸ¥µğŸ™ŒğŸ“¼ğŸ“¡ğŸ’µğŸŒğŸ§‚ğŸ§‚  ğŸ“¼ğŸ§ ğŸš€ğŸŒ›ğŸ’¥ğŸŒğŸ§‚ğŸ§ ğŸŒğŸ§¨ğŸ§‚ğŸ‘„ğŸŒŸğŸ’¾ğŸ§ ğŸ§ ğŸ’¯ğŸ“¡ğŸ’µğŸ—¿ğŸ§¨ğŸŒŸğŸ‘€ğŸ™ŒğŸ‘½ğŸ¦ğŸ™ŒğŸ’¯ğŸŒ›ğŸ¤¯ğŸ’©ğŸ’½ğŸ’©ğŸŒ›ğŸ‘½ğŸ¤ŸğŸ¤¯ğŸŒŸğŸ—¿ğŸ¤ŸğŸ’©ğŸ’¾ğŸŒğŸ—¿ğŸ¤¯ğŸ‘„ğŸ‘„ğŸ¤ŸğŸ’©ğŸ¥µğŸ¤¯ğŸ’¥ğŸ“¼ğŸ¥ƒğŸ’¯ğŸ’¥ğŸ’¾ğŸ§¨ğŸ’¾ğŸš€ğŸ’¥ğŸ¦ğŸ’¥ğŸ’¯ğŸ¦ğŸ‰ğŸŒ›ğŸ¤ŸğŸ›°ğŸ—¿ğŸŒğŸ‘½ğŸ¤ŸğŸ’¯ğŸ“¡ğŸ”¥ğŸ”¥ğŸŒŸğŸ¤¯ğŸ¥ƒğŸ”¥ğŸ‰ğŸ“¼ğŸŒğŸ™ŒğŸ‘€ğŸŒğŸ‘€ğŸ’¥ğŸš€ğŸ§‚ğŸŒŸğŸ¤ŸğŸŒğŸš€ğŸ¥µğŸ’½ğŸ‘€ğŸ“¡ğŸ¦ğŸ§ ğŸ¤ŸğŸ’¥ğŸ’µğŸŒğŸ¥µğŸ§¨ğŸ™ŒğŸ’½ğŸ‰ğŸ™ŒğŸ’¯ğŸ§‚ğŸŒŸğŸ‰ğŸ’¯ğŸ§ ğŸ¤Ÿ```

ğŸ‡² ğŸ‡ª ğŸ‡³ ğŸ‡º
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   1âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡« ğŸ‡¦ ğŸ‡¨ ğŸ‡¹ ğŸ‡´ ğŸ‡· ğŸ‡¸   ğŸ‡´ ğŸ‡«   ğŸ‡¦ ğŸ‡³   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   2âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¦   ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸ‡§ ğŸ‡¾   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   3âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡« ğŸ‡¦ ğŸ‡¨ ğŸ‡¹ ğŸ‡´ ğŸ‡· ğŸ‡¸   ğŸ‡´ ğŸ‡«   ğŸ‡¦   ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   ğŸ‡³ ğŸ‡º ğŸ‡² ğŸ‡§ ğŸ‡ª ğŸ‡·   ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹   ğŸ‡® ğŸ‡¸   ğŸ‡¦ ğŸ‡¹   ğŸ‡´ ğŸ‡» ğŸ‡ª ğŸ‡·   5âƒ£   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸   ğŸ‡® ğŸ‡³   ğŸ‡¸ ğŸ‡® ğŸ‡¿ ğŸ‡ª
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   ğŸ‡¦ ğŸ‡³ ğŸ‡¾ ğŸ‡¹ ğŸ‡­ ğŸ‡® ğŸ‡³ ğŸ‡¬   ğŸ‡ª ğŸ‡± ğŸ‡¸ ğŸ‡ª   ğŸ‡¹ ğŸ‡´   ğŸ‡ª ğŸ‡½ ğŸ‡® ğŸ‡¹
```
Each emoji represents a 32-based number, and the N, E, C show that this is relative to RSA. So that the first step is solve the value of every emoji.  
## Emoji decode part
Z3 solver is the first things pop in my mind.  
At first, I use a python script to get factors of every emoji by menu option 1.  
(here is supposed to be a script, but I lost it)  
therefore, here is the result:
```python
{'ğŸ‰': '0', 'ğŸ›°': '1', 'ğŸ¥ƒ': '2', 'ğŸŒ': ' ğŸ›°  ğŸŒ ', 'ğŸ’¾': ' ğŸ›°  ğŸ¦  ğŸŒŸ  ğŸ’¾ ', 'ğŸ›¸': ' ğŸ›°  ğŸ¦  ğŸ¥ƒ  ğŸ›¸ ', 'ğŸ¤¯': ' ğŸ›°  ğŸŒ  ğŸ¤¯ ', 'ğŸ™Œ': ' ğŸ›°  ğŸ™Œ ', 'ğŸ“¡': ' ğŸ›°  ğŸ“¡  ğŸ¥ƒ ', 'ğŸ¦': ' ğŸ›°  ğŸ¦ ', 'ğŸ‘€': ' ğŸ›°  ğŸ¥ƒ  ğŸŒ  ğŸ‘€ ', 'ğŸ’¥': ' ğŸ¦  ğŸ¥ƒ  ğŸ›°  ğŸ’©  ğŸ’½  ğŸ’¥  ğŸ“¡  ğŸ›¸ ', 'ğŸ¥µ': ' ğŸ¥ƒ  ğŸ›°  ğŸ’©  ğŸ“¡  ğŸ¥µ ', 'ğŸ’©': ' ğŸ’©  ğŸ›°  ğŸ“¡  ğŸ¥ƒ ', 'ğŸ’µ': ' ğŸ¦  ğŸŒŸ  ğŸ¥ƒ  ğŸ›°  ğŸ’µ  ğŸ›¸ ', 'ğŸŒ›': ' ğŸ¦  ğŸ¥ƒ  ğŸ§   ğŸ›°  ğŸŒ  ğŸ‘€  ğŸŒ›  ğŸ›¸ ', 'ğŸŒ': ' ğŸ›°  ğŸŒ  ğŸ¥ƒ  ğŸŒ ', 'ğŸŒŸ': ' ğŸ›°  ğŸ¦  ğŸŒŸ ', 'ğŸ‘½': ' ğŸ›°  ğŸ‘½ ', 'ğŸ—¿': ' ğŸ›°  ğŸ—¿  ğŸ¦  ğŸš€ ', 'ğŸŒ': ' ğŸ›°  ğŸŒ ', 'ğŸ’½': ' ğŸ¦  ğŸ¥ƒ  ğŸ›°  ğŸ’½  ğŸ“¡  ğŸ›¸ ', 'ğŸ‘„': ' ğŸ›°  ğŸ‘„ ', 'ğŸŒ': ' ğŸŒ  ğŸ¥ƒ  ğŸ›°  ğŸš€  ğŸ“¡  ğŸ§¨ ', 'ğŸ”¥': ' ğŸ›°  ğŸ”¥ ', 'ğŸ¤Ÿ': ' ğŸ›°  ğŸ¤Ÿ ', 'ğŸ§¨': ' ğŸ›°  ğŸš€  ğŸ§¨  ğŸ¥ƒ ', 'ğŸ§‚': ' ğŸ›°  ğŸ§‚ ', 'ğŸš€': ' ğŸ›°  ğŸš€ ', 'ğŸ§ ': ' ğŸ›°  ğŸŒ  ğŸ¦  ğŸ§  ', 'ğŸ’¯': ' ğŸ›°  ğŸ”¥  ğŸ’¯  ğŸ¥ƒ ', 'ğŸ“¼': ' ğŸ¥ƒ  ğŸ›°  ğŸŒ  ğŸ“¼  ğŸ“¡  ğŸ‘€ '}
```
Then, is the time for z3.  
Firstly, build a `z3.Int` list, which represents every emoji's value.  
```python
words={'ğŸ‰': '0', 'ğŸ›°': '1', 'ğŸ¥ƒ': '2', 'ğŸŒ': ' ğŸ›°  ğŸŒ ', 'ğŸ’¾': ' ğŸ›°  ğŸ¦  ğŸŒŸ  ğŸ’¾ ', 'ğŸ›¸': ' ğŸ›°  ğŸ¦  ğŸ¥ƒ  ğŸ›¸ ', 'ğŸ¤¯': ' ğŸ›°  ğŸŒ  ğŸ¤¯ ', 'ğŸ™Œ': ' ğŸ›°  ğŸ™Œ ', 'ğŸ“¡': ' ğŸ›°  ğŸ“¡  ğŸ¥ƒ ', 'ğŸ¦': ' ğŸ›°  ğŸ¦ ', 'ğŸ‘€': ' ğŸ›°  ğŸ¥ƒ  ğŸŒ  ğŸ‘€ ', 'ğŸ’¥': ' ğŸ¦  ğŸ¥ƒ  ğŸ›°  ğŸ’©  ğŸ’½  ğŸ’¥  ğŸ“¡  ğŸ›¸ ', 'ğŸ¥µ': ' ğŸ¥ƒ  ğŸ›°  ğŸ’©  ğŸ“¡  ğŸ¥µ ', 'ğŸ’©': ' ğŸ’©  ğŸ›°  ğŸ“¡  ğŸ¥ƒ ', 'ğŸ’µ': ' ğŸ¦  ğŸŒŸ  ğŸ¥ƒ  ğŸ›°  ğŸ’µ  ğŸ›¸ ', 'ğŸŒ›': ' ğŸ¦  ğŸ¥ƒ  ğŸ§   ğŸ›°  ğŸŒ  ğŸ‘€  ğŸŒ›  ğŸ›¸ ', 'ğŸŒ': ' ğŸ›°  ğŸŒ  ğŸ¥ƒ  ğŸŒ ', 'ğŸŒŸ': ' ğŸ›°  ğŸ¦  ğŸŒŸ ', 'ğŸ‘½': ' ğŸ›°  ğŸ‘½ ', 'ğŸ—¿': ' ğŸ›°  ğŸ—¿  ğŸ¦  ğŸš€ ', 'ğŸŒ': ' ğŸ›°  ğŸŒ ', 'ğŸ’½': ' ğŸ¦  ğŸ¥ƒ  ğŸ›°  ğŸ’½  ğŸ“¡  ğŸ›¸ ', 'ğŸ‘„': ' ğŸ›°  ğŸ‘„ ', 'ğŸŒ': ' ğŸŒ  ğŸ¥ƒ  ğŸ›°  ğŸš€  ğŸ“¡  ğŸ§¨ ', 'ğŸ”¥': ' ğŸ›°  ğŸ”¥ ', 'ğŸ¤Ÿ': ' ğŸ›°  ğŸ¤Ÿ ', 'ğŸ§¨': ' ğŸ›°  ğŸš€  ğŸ§¨  ğŸ¥ƒ ', 'ğŸ§‚': ' ğŸ›°  ğŸ§‚ ', 'ğŸš€': ' ğŸ›°  ğŸš€ ', 'ğŸ§ ': ' ğŸ›°  ğŸŒ  ğŸ¦  ğŸ§  ', 'ğŸ’¯': ' ğŸ›°  ğŸ”¥  ğŸ’¯  ğŸ¥ƒ ', 'ğŸ“¼': ' ğŸ¥ƒ  ğŸ›°  ğŸŒ  ğŸ“¼  ğŸ“¡  ğŸ‘€ '}
from z3 import IntVal, Int, Solver, Distinct
s=Solver()
vals=[IntVal(a) for a in range(3)] + [Int("val" + str(i))]
```
Then add basic constraints (2 < value < 32) for every emoji.  
```python
for v in vals[3:]:
    s.add(v >= IntVal(3))
    s.add(v < IntVal(32))

# bc each value should be distinct
s.add(Distinct(vals))
```
Absolutely we can run with these basic constraints, but the result will be ambiguous. Therefore, we need to add more constraints from menu option 2 (get random prime emoji in specific bits):  
```python
def addConstraintOfPrimeBit(num, bitNum):
    global s, vals
    val=vals[num]
    lowerBound=int('1' + '0' * (bitNum - 1), 2)
    # add lower bound constrains
    s.add(val<=IntVal(int('1' * bitNum, 2)))
    # add upper  bound constraint
    s.add(val>=IntVal(lowerBound))
    # add prime constraint
    if lowerBound > 2:
        for i in range(2, lowerBound):
            # print(f"val{num} % {i} != 0")
            s.add(val % IntVal(i) != IntVal(0))
```
And manually get some emojis from menu option 2.
```python
# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   2âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸ¦
# ğŸ¦ is prime and ğŸ¦ is 2bits, so 2 < it <= 3
addConstraintOfPrimeBit(keys.index('ğŸ¦'), 2)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   3âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸŒ
addConstraintOfPrimeBit(keys.index('ğŸŒ'), 3)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   3âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸš€
addConstraintOfPrimeBit(keys.index('ğŸš€'), 3)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   4âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸ”¥
addConstraintOfPrimeBit(keys.index('ğŸ”¥'), 4)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   4âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸŒ
addConstraintOfPrimeBit(keys.index('ğŸŒ'), 4)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   5âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸ™Œ
addConstraintOfPrimeBit(keys.index('ğŸ™Œ'), 5)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   5âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸ§‚
addConstraintOfPrimeBit(keys.index('ğŸ§‚'), 5)

# ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   5âƒ£   â– ğŸ‡§ ğŸ‡® ğŸ‡¹   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸŸ°    ğŸ‘„
addConstraintOfPrimeBit(keys.index('ğŸ‘„'), 5)
```
But the result is still ambiguous (at least one emoji value is ambiguous, e.g. ğŸ’¯ can be 22 or 26). At first, I try to utilize results from menu option 3, but those constrains will make solver `unsat` (although we don't care what is the value of those random bits value):
```python
# these stuff will make solver be unsat. I don't know why
# #  ğŸ¦  ğŸ›°ğŸ’¯  ğŸ›¸  ğŸ’µ  ğŸŒŸ  ğŸ¥ƒ  ğŸ›°  ğŸ’¾ of 6 bits
# random_6_bit = Int("random_6_bit")
# s.add(random_6_bit % vals[keys.index('ğŸ¦')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ’¯')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ›¸')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ’µ')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸŒŸ')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ¥ƒ')] == IntVal(0))
# s.add(random_6_bit % vals[keys.index('ğŸ’¾')] == IntVal(0))
# s.add(random_6_bit >= IntVal(int('100000', 2)))
# s.add(random_6_bit <= IntVal(int('111111', 2)))

# #  ğŸ›°  ğŸŒ  ğŸ¦  ğŸ›°ğŸš€ of 6 bits
# random_6_bit2 = Int("random_6_bit2")
# s.add(random_6_bit2 % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('ğŸŒ')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('ğŸ¦')] == IntVal(0))
# s.add(random_6_bit2 % vals[keys.index('ğŸš€')] == IntVal(0))
# s.add(random_6_bit2 >= IntVal(int('100000', 2)))
# s.add(random_6_bit2 <= IntVal(int('111111', 2)))

# #  ğŸ‘€  ğŸ›°ğŸ’©  ğŸŒ  ğŸ¥ƒ  ğŸ’©  ğŸ“¼  ğŸ“¡  ğŸ›° of 6 bits
# random_6_bit3 = Int("random_6_bit3")
# s.add(random_6_bit3 % vals[keys.index('ğŸ‘€')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ’©')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸŒ')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ¥ƒ')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ’©')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ“¼')] == IntVal(0))
# s.add(random_6_bit3 % vals[keys.index('ğŸ“¡')] == IntVal(0))
# s.add(random_6_bit3 >= IntVal(int('100000', 2)))
# s.add(random_6_bit3 <= IntVal(int('111111', 2)))

# # ğŸ¥ƒ  ğŸ¤Ÿ  ğŸ›°  ğŸ›°ğŸ›¸ of 6 bits
# random_6_bit4 = Int("random_6_bit4")
# s.add(random_6_bit4 % vals[keys.index('ğŸ¥ƒ')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('ğŸ¤Ÿ')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_6_bit4 % vals[keys.index('ğŸ›¸')] == IntVal(0))
# s.add(random_6_bit4 >= IntVal(int('100000', 2)))
# s.add(random_6_bit4 <= IntVal(int('111111', 2)))

# # ğŸŒ  ğŸ¦ğŸ¥µ  ğŸš€  ğŸ¥ƒ  ğŸ§¨  ğŸ¥µ  ğŸ’©  ğŸ›°ğŸ’¥  ğŸ“¡  ğŸ›° of 7 bits
# random_7_bit = Int("random_7_bit")
# s.add(random_7_bit % vals[keys.index('ğŸŒ')] == IntVal(0))
# s.add(random_7_bit % (vals[keys.index('ğŸ¦')] * vals[keys.index('ğŸ¥µ')]) == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸš€')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ¥ƒ')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ§¨')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ¥µ')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ’©')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ’¥')] == IntVal(0))
# s.add(random_7_bit % vals[keys.index('ğŸ“¡')] == IntVal(0))
# s.add(random_7_bit >= IntVal(int('1000000', 2)))
# s.add(random_7_bit <= IntVal(int('1111111', 2)))

# #  ğŸ›°ğŸ‘½  ğŸ¦ğŸ¥ƒ  ğŸ§¨  ğŸ¥ƒ  ğŸš€  ğŸ›° for 7 bits
# random_7_bit2 = Int("random_7_bit2")
# s.add(random_7_bit2 % (vals[keys.index('ğŸ‘½')]) == IntVal(0))
# s.add(random_7_bit2 % (vals[keys.index('ğŸ¦')] * vals[keys.index('ğŸ¥ƒ')]) == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('ğŸ§¨')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('ğŸ¥ƒ')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('ğŸš€')] == IntVal(0))
# s.add(random_7_bit2 % vals[keys.index('ğŸ›°')] == IntVal(0))
# s.add(random_7_bit2 >= IntVal(int('1000000', 2)))
# s.add(random_7_bit2 <= IntVal(int('1111111', 2)))
```
Therefore, there is no choice but do some manually analysis (analyzed by **qxxxb**):
```python
# manually found, if not, there will be some ambiguity, e.g. ğŸ’¯ can be 22 or 26
s.add(vals[keys.index('ğŸ“¡')] == IntVal(4))
s.add(vals[keys.index('ğŸ’©')] == IntVal(8))
s.add(vals[keys.index('ğŸ¥µ')] == IntVal(16))
s.add(vals[keys.index('ğŸ›¸')] == IntVal(6))
s.add(vals[keys.index('ğŸ’½')] == IntVal(12))
s.add(vals[keys.index('ğŸš€')] == IntVal(7))
s.add(vals[keys.index('ğŸŒ')] == IntVal(5))
s.add(vals[keys.index('ğŸ”¥')] == IntVal(11))
s.add(vals[keys.index('ğŸŒ')] == IntVal(13))
s.add(vals[keys.index('ğŸ§‚')] == IntVal(23))
s.add(vals[keys.index('ğŸ‘½')] == IntVal(17))
s.add(vals[keys.index('ğŸ¤Ÿ')] == IntVal(19))
s.add(vals[keys.index('ğŸ™Œ')] == IntVal(29))
s.add(vals[keys.index('ğŸ‘„')] == IntVal(31))
```
and the part print result:  
```python
print("constraints added finished")
print(s.check())
model = str(s.model())
print(model)
```
Our z3 script is finished, and offer us a transcript between emoji and 32-based integer:
```
 {'ğŸ‰': 0, 'ğŸ›°': 1, 'ğŸ¥ƒ': 2, 'ğŸ’¯': 22, 'ğŸ§ ': 15, 'ğŸ‘€': 10, 'ğŸ¥µ': 16, 'ğŸŒ›': 30, 'ğŸ™Œ': 29, 'ğŸ‘½': 17, 'ğŸ¤¯': 25, 'ğŸŒ': 26, 'ğŸ’¾': 27, 'ğŸ’½': 12, 'ğŸ—¿': 21, 'ğŸš€': 7,  'ğŸ’µ': 18, 'ğŸŒ': 13, 'ğŸ§¨': 14, 'ğŸ’¥': 24, 'ğŸ’©': 8, 'ğŸ¤Ÿ': 19, 'ğŸ§‚': 23, 'ğŸ¦': 3, 'ğŸ”¥': 11, 'ğŸ“¡': 4, 'ğŸ‘„': 31, 'ğŸ›¸': 6, 'ğŸŒŸ': 9, 'ğŸŒ': 5, 'ğŸ“¼': 20, 'ğŸŒ': 28}
```
## RSA decode part
At first, we though the N, E and C is a RSA cipher (but it is not).  So we spend a lot of time on `RsaCtfTool` and `Yafu` to attack this RSA, and we got nothing.  
Eventually, after this CTF is over, we figure out that this is a RSA signature (from Discord).  
So, this is the last piece of script (wrote by **qxxxb**):
```python
transcript = emojis

import pwn

def digit_to_keycap(n: int) -> bytes:
    assert 0 <= n < 10
    return str(n).encode() + b"\xe2\x83\xa3"

def emojis_to_n(emojis: str) -> int:
    n = 0
    for emoji in emojis:
        x = transcript[emoji]
        n = n * 32 + x
    return n

pwn.context.log_level = "debug"

io = pwn.remote("emoji.quals2023.satellitesabove.me", 5300)
io.sendlineafter(
    b"Ticket please:\n",
    b"ticket",
)

io.recvuntil("ğŸ‡³   ğŸŸ°   ")
N = io.recvline().strip().decode()

io.recvuntil("ğŸ‡ª   ğŸŸ°   ")
E = io.recvline().strip().decode()

io.recvuntil("ğŸ‡¨   ğŸŸ°   ")
C = io.recvline().strip().decode()

n = emojis_to_n(N)
e = emojis_to_n(E)
c = emojis_to_n(C)

print(f"n = {n}")
print(f"e = {e}")
print(f"c = {c}")

import Crypto.Util.number as cun

p = pow(c, e, n)

# flag
print(cun.long_to_bytes(p))
```
# Solution
check `solve.py` in same directory.